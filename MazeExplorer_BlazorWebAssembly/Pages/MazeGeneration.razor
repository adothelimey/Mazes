@page "/mazegen"
@using System.Drawing;
@using TheGrid;
@using TheGrid.Mazes.Algorithms;
@inject IJSRuntime JSRuntime

<PageTitle>Maze Generation</PageTitle>

<button class="btn btn-primary" @onclick="CreateNewMaze">NewMaze</button>

<EditForm Model="@currentMazeSettings" OnValidSubmit="@CreateNewMaze">
    <DataAnnotationsValidator />
    <ValidationSummary />

    <p>
        <label>
            Number of Rows
            <InputNumber @bind-Value="currentMazeSettings.NumberOfRows" />
        </label>
    </p>
    <p>
        <label>
            Number of Columns
            <InputNumber @bind-Value="currentMazeSettings.NumberOfColumns" />
        </label>
    </p>
    <p>
        <label>
            Cell Width
            <InputNumber @bind-Value="currentMazeSettings.CellWidth" />
        </label>
    </p>
    <p>
        <label>
            Cell Height
            <InputNumber @bind-Value="currentMazeSettings.CellHeight" />
        </label>
    </p>
    <p>
        <label>
            Maze Algorithm:
            <InputSelect @bind-Value="currentMazeSettings.AlgoIndex">
                <option value="0">Select an algortihm...</option>
                <option value="1">Binary Tree</option>
                <option value="2">Sidewinder</option>
                <option value="3">Aldous-Broder</option>
            </InputSelect>
        </label>
    </p>

        <button type="submit">Submit</button>


    </EditForm>

<canvas id="canvas"></canvas>



@code {

    Grid? grid { get; set; }
    MazeSettings currentMazeSettings = new MazeSettings { CellHeight = 16, CellWidth = 16, NumberOfColumns = 16, NumberOfRows = 16 };

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JSRuntime.InvokeVoidAsync("initCanvas", "canvas");
        }
    }

    private void CreateNewMaze()
    {

        //creates new grid with specified parameters (grid size, line width and colour etc)
        //currentMazeSettings = new MazeSettings
        //    {
        //        NumberOfRows = (int)num_GridHeight.Value,
        //        NumberOfColumns = (int)numGridWidth.Value,
        //        CellWidth = (int)numCellWidth.Value,
        //        CellHeight = (int)numCellHeight.Value,
        //        AlgoIndex = cboAlgoSelector.SelectedIndex
        //    };
        grid = new Grid(currentMazeSettings.NumberOfRows, currentMazeSettings.NumberOfColumns);

        MazeAlgorithm? algo = currentMazeSettings.AlgoIndex switch
        {
            3 => new AldousBroder(),
            2 => new Sidewinder(),
            1 => new BinaryTree(),
            0 => null
        };

        //var stopWatch = new Stopwatch();
        //stopWatch.Start();
        algo?.ExecuteOn(grid);
        //stopWatch.Stop();
        //toolStripStatusLabel1.Text = $"Maze generation took {stopWatch.ElapsedTicks} ticks";

        //panel_Draw.AutoScroll = false;
        //panel_Draw.Size = new Size(grid.Columns * currentMazeSettings.CellWidth, grid.Rows * currentMazeSettings.CellHeight);
        //panel_Draw.AutoScroll = true;
        //panel_Draw.Invalidate();

        var magicNumber = 12;
        //this._context = await this._canvasReference.CreateCanvas2DAsync();
        //await this._context.ClearRectAsync(0, 0, _canvasReference.Width, _canvasReference.Height);

        for (var x = 0; x < grid.Columns; x++)
        {
            for (var y = 0; y < grid.Rows; y++)
            {

                var xPos = x * currentMazeSettings.CellWidth;
                var yPos = y * currentMazeSettings.CellHeight;

                var northRect = new Rectangle(xPos, yPos, currentMazeSettings.CellWidth, currentMazeSettings.CellHeight / magicNumber);
                var eastRect = new Rectangle(xPos + (currentMazeSettings.CellWidth - (currentMazeSettings.CellWidth / magicNumber)), yPos, currentMazeSettings.CellWidth / magicNumber, currentMazeSettings.CellHeight);
                var southRect = new Rectangle(xPos, yPos + (currentMazeSettings.CellHeight - (currentMazeSettings.CellHeight / magicNumber)), currentMazeSettings.CellWidth, currentMazeSettings.CellHeight / magicNumber);
                var westRect = new Rectangle(xPos, yPos, currentMazeSettings.CellWidth / magicNumber, currentMazeSettings.CellHeight);

                var cell = grid.GetCellAt(x, y);


                //var farthestCell = distances.FurthestCellFromRoot();

                if (cell != null)
                {
                    //if (distances.CellsAndTheirDistanceFromRoot.TryGetValue(cell, out int value))
                    //{
                    //    var distance = value;
                    //    var shadeColour = Color.Green;

                    //    var distanceColour = AdjustColorForDistance(shadeColour, distance, farthestCell.Value);
                    //    Brush brush = new SolidBrush(distanceColour);


                    //    graphics.FillRectangle(brush, new Rectangle(xPos, yPos, currentMazeSettings.CellWidth, currentMazeSettings.CellHeight));
                    //}

                    //await _context.SetFillStyleAsync("green");

                    if (!cell.HasLinkedNeighbourInDirection(Direction.North))
                    {
                        //await _context.SetFillStyleAsync("green");
                        JSRuntime.InvokeVoidAsync("drawRectangle", northRect.X, northRect.Y, northRect.Width, northRect.Height, "black");
                        //await _context.FillRectAsync(northRect.X, northRect.Y, northRect.Width, northRect.Height);
                    }
                    if (!cell.HasLinkedNeighbourInDirection(Direction.East))
                    {
                        //await this._context.SetFillStyleAsync("black");
                        JSRuntime.InvokeVoidAsync("drawRectangle", eastRect.X, eastRect.Y, eastRect.Width, eastRect.Height, "black");
                        //await this._context.FillRectAsync(eastRect.X, eastRect.Y, eastRect.Width, eastRect.Height); ;
                    }
                    if (!cell.HasLinkedNeighbourInDirection(Direction.South))
                    {
                        //await this._context.SetFillStyleAsync("black");
                        JSRuntime.InvokeVoidAsync("drawRectangle", southRect.X, southRect.Y, southRect.Width, southRect.Height, "black");
                        //await this._context.FillRectAsync(southRect.X, southRect.Y, southRect.Width, southRect.Height);
                    }
                    if (!cell.HasLinkedNeighbourInDirection(Direction.West))
                    {
                        //await this._context.SetFillStyleAsync("black");
                        JSRuntime.InvokeVoidAsync("drawRectangle", westRect.X, westRect.Y, westRect.Width, westRect.Height, "black");
                        //await this._context.FillRectAsync(westRect.X, westRect.Y, westRect.Width, westRect.Height);
                    }

                    //if (chkShowCoordinates.Checked)
                    //{
                    //    drawCoordinates(graphics, cell, xPos, yPos);
                    //}

                    //if (distances.CellsAndTheirDistanceFromRoot.TryGetValue(cell, out int value2))
                    //{
                    //    var distance = value2;
                    //    graphics.DrawString($"{distance}", DefaultFont, Brushes.Black, new PointF(xPos, yPos));
                    //}
                }
            }
        }
    }

   


}
